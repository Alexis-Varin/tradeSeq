---
title: 'Vignette for **tradeR**: **tra**jectory **d**ifferential **e**xpression analysis in **R**'
author: "Koen Van den Berge"
bibliography: tradeR.bib
date: "9/10/2018"
output: html_document
---

In this vignette, we analyse a subset of the data from [@Paul2015]. 
A `SingleCellExperiment` object of the data has been provided with the `tradeR` package and can be retrieved with `data(se)`. The data and UMAP reduced dimensions were derived from following the [Monocle 3 vignette](http://cole-trapnell-lab.github.io/monocle-release/monocle3/#tutorial-1-learning-trajectories-with-monocle-3). 

# load data

```{r}
suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(mgcv)
  library(tradeR)
  library(slingshot)
  library(RColorBrewer)
  library(scales)
})
palette(brewer.pal(9,"Dark2"))
data(se, package="tradeR")
se
```

# fit trajectories using slingshot

We will fit developmental trajectories usling the `slingshot` package [@Street2018a]. `slingshot` requires cluster labels as input, and fits trajectories in reduced dimension. We will use the reduced space calculated with the UMAP method, which is precalculated in the `se` object.
We cluster the data using k-means with $7$ clusters. Since we know which cells are the progenitor cell type, we define the starting point for the trajectories as input for `slingshot`. Note that this argument is optional, and not required to run `slingshot`.

```{r}
set.seed(97)
rd <- reducedDims(se)$UMAP
cl <- kmeans(rd, centers = 7)$cluster
plot(rd, col = brewer.pal(9,"Set1")[cl], pch=16, asp = 1)
library(slingshot)
lin <- getLineages(rd, clusterLabels=cl, start.clus=4)
plot(rd,col=brewer.pal(9,"Set1")[cl], xlab="UMAP1", ylab="UMAP2")
lines(lin, lwd=3, col="black")
crv <- getCurves(lin)
plot(rd,col=brewer.pal(9,"Set1")[cl], main="color by cluster", xlab="UMAP1", ylab="UMAP2")
lines(crv, lwd=3, col="black")

```

We find two trajectories for this dataset. We can futher color the cells according to their cell type.

```{r}
celltype <- factor(colData(se)$cell_type2)
plot(rd,col=alpha(brewer.pal(9,"Set1")[celltype],.5), main="color by cell type", xlab="UMAP1", ylab="UMAP2", pch=16, cex=2/3)
lines(crv, lwd=3, col="black")
legend("topright",levels(celltype), col=brewer.pal(9,"Set1")[1:nlevels(celltype)], pch=16, cex=1/2, bty='n')
```

# Fit additive models

After estimating the trajectories, we can fit generalized additive models (GAMs) with the `tradeR` package. Internally, this package builds on the `mgcv` package by fitting additive models using the `gam` function. The core function from `tradeR`, `fitGAM` will use cubic splines as basis functions, and it tries to ensure that every trajectory will end at a knot point of a basis function. By default, we allow for $10$ knots for every trajectory, but this can be changed with the `nknots` function.
By default, we estimate one smoothers for every trajectory in the GAM using the negative binomial distribution. If you want to allow for other fixed effects (e.g. batch effects), then an additional model matrix can be provided with the `X` argument. 
We use the effective library size, estimated with TMM [@Robinson2010], as offset in the model. We allow for alternatives by providing a user-defined offset with the `offset` argument.
This dataset consists of UMI counts, and we do not expect zero inflation to be a big problem here. However, we also allow to fit zero inflated negative binomial (ZINB) GAMs by providing observation-level weights to `fitGAM` using the `weights` argument. The `weights` must correspond to the posterior probability that a count belongs to the zero inflation component of the ZINB distribution [@VandenBerge2018].
For the vignette, we fit smoothers for the first 150 genes in the dataset. We also include the *Irf8* gene, since it is a known transcription factor involved in hematopoiesis.

```{r}
counts <- assays(se)$counts[c(1:150,1360),]
gamList <- fitGAM(counts=counts, pseudotime=slingPseudotime(crv, na=FALSE), cellWeights=slingCurveWeights(crv))
```

One may explore the results of a model by requesting its summary.

```{r}
summary(gamList[[1]])
```

# Within-lineage comparisons

## Association of gene expression with pseudotime

A fist exploration of the data analysis may consist in checking whether a gene is associated with a particular lineage.
The statistical test performed here is testing the null hypothesis that all smoother coefficients are equal to zero.
One can check whether a gene is significantly associated with a particular lineage by extracting its p-value with the `getSmootherPvalues` function.
This function extracts the p-values calculated by `mgcv` from the GAM, and will return `NA` for genes that we were unable to fit properly.
Similarly, the test statistics may be extracted with `getSmootherTestStats`.
Since this dataset was prefiltered to only contain relevant genes, all p-values (test statistics) will be very low (high).

```{r}
pvalLineage <- getSmootherPvalues(gamList)
statLineage <- getSmootherTestStats(gamList)
```

## Discovering progenitor marker genes

In order to discover marker genes of the progenitor cell population, researchers may be interested in assessing differential expression between the progenitor cell population (i.e., the starting point of a trajectory) with the differentiated cell type population.
In the function `startPointTest`, we have implemented a Wald test that tests the null hypothesis that the expression at the starting point of the smoother (progenitor population) is identical to the expression at the end point of the smoother (differentiated population).
The test basically involves a comparison between two smoother coefficients for every lineage.
The function `startPointTest` performs an omnibus across all trajectories by default, but you can also assess all pairwise comparisons separately by setting `pairwise=TRUE`.
Below, we adopt an omnibus test across the two lineages.

```{r}
startRes <- startPointTest(gamList)
```

We can visualize the estimated smoothers for the most significant gene.

```{r}
oStart <- order(startRes$waldStat, decreasing=TRUE)
sigGeneStart <- names(gamList)[oStart[1]]
plotSmoothers(gamList[[sigGeneStart]])
```

Alternatively, we can color the cells in UMAP space with that gene's expression.

```{r}
cols <- colorRampPalette(c("yellow","red"))(10)
g <- Hmisc::cut2(log(assays(se)$counts[sigGeneStart,]+1))
plot(rd,col=cols[g], main=paste0("color by expression of ",sigGeneStart), xlab="UMAP1", ylab="UMAP2", pch=16, cex=2/3)
lines(crv, lwd=3, col="black")
```


# Between-lineage comparisons

## Discovering differentiated cell type markers

`tradeR` can discover marker genes for the differentiated cell types by comparing the end points of the lineage-specific smoothers. This is implemented in the `endPointTest` function.
By default, `endPointTest` performs an omnibus test, testing the null hypothesis that the endpoint expression is equal for all trajectories using a multivariate Wald test.
If more than two trajectories are present, one can assess all pairwise comparisons using the `pairwise=TRUE` argument.

```{r}
endRes <- endPointTest(gamList)
```

We can plot the most significant gene using the `plotSmoothers` function.

```{r}
o <- order(endRes$waldStat, decreasing=TRUE)
sigGene <- names(gamList)[o[1]]
plotSmoothers(gamList[[sigGene]])
```

Alternatively, we can color the cells in UMAP space with that gene's expression.

```{r}
cols <- colorRampPalette(c("yellow","red"))(10)
g <- Hmisc::cut2(log(assays(se)$counts[sigGene,]+1))
plot(rd,col=cols[g], main=paste0("color by expression of ",sigGene), xlab="UMAP1", ylab="UMAP2", pch=16, cex=2/3)
lines(crv, lwd=3, col="black")
```

## Discovering genes with different expression patterns

Asides from testing at the level of the differentiated cell type level, researchers may be interested in assessing the expression pattern of a gene over time.
The function `patternTest` implements a statistical method that tests the null hypothesis of whether all smoother coefficients are equal to each other.
Due to our construction of the smoothers, which have identical smoothing penalties, knots and basis functions, genes with similar expression patterns will have similar smoothing coefficients.
Hence, if all coefficients are similar, the expression patterns will be similar.

```{r}
patternRes <- patternTest(gamList)
oPat <- order(patternRes$waldStat, decreasing=TRUE)
head(oPat) #note that the most significant gene is the Irf8 gene.
```

Similar to above, we can plot the estimated functions for the most significant gene.

```{r}
sigGenePat <- names(gamList)[oPat[1]]
plotSmoothers(gamList[[sigGenePat]])
```

Or, we can visualize its expression in UMAP space.

```{r}
cols <- colorRampPalette(c("yellow","red"))(10)
g <- Hmisc::cut2(log(assays(se)$counts[sigGenePat,]+1))
plot(rd,col=cols[g], main=paste0("color by expression of ",sigGenePat), xlab="UMAP1", ylab="UMAP2", pch=16, cex=2/3)
lines(crv, lwd=3, col="black")
```

# References
